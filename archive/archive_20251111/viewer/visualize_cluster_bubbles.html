<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Interactive Cluster Bubble Visualization</title>

    <!-- Google Fonts for multi-language support -->
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Noto+Sans:wght@400;600&family=Noto+Sans+KR:wght@400;600&family=Noto+Sans+SC:wght@400;600&display=swap"
      rel="stylesheet"
    />

    <style>
      /* ============================================
         GLOBAL STYLES
         ============================================ */
      :root {
        color-scheme: light;
      }

      body {
        margin: 0;
        font-family: "Noto Sans KR", "Noto Sans SC", "Noto Sans", "Segoe UI",
          "Helvetica Neue", Arial, sans-serif;
        background: #f5f7fb;
        color: #1f2937;
      }

      main {
        display: flex;
        flex-direction: column;
        gap: 16px;
        padding: 18px 24px 32px 24px;
        min-height: 100vh;
        box-sizing: border-box;
      }

      /* ============================================
         HEADER & CONTROLS
         ============================================ */
      header {
        display: flex;
        flex-wrap: wrap;
        align-items: center;
        justify-content: space-between;
        gap: 12px;
      }

      header h1 {
        margin: 0;
        font-size: 22px;
        font-weight: 600;
      }

      .controls {
        display: flex;
        flex-wrap: wrap;
        gap: 16px;
        align-items: center;
      }

      .control {
        display: flex;
        align-items: center;
        gap: 8px;
        font-size: 14px;
        background: #ffffff;
        padding: 6px 12px;
        border-radius: 12px;
        box-shadow: 0 2px 10px rgba(15, 23, 42, 0.08);
      }

      /* ============================================
         VISUALIZATION CONTAINER
         ============================================ */
      #viz-container {
        flex: 1 1 auto;
        min-height: 1200px;
        background: #ffffff;
        border-radius: 18px;
        box-shadow: 0 12px 40px rgba(15, 23, 42, 0.12);
        position: relative;
        overflow: hidden;
        display: flex;
        flex-direction: column;
      }

      #svg-wrapper {
        flex: 1;
        width: 100%;
        height: 100%;
        position: relative;
      }

      svg {
        width: 100%;
        height: 100%;
        display: block;
        cursor: grab;
        position: absolute;
        top: 0;
        left: 0;
      }

      svg:active {
        cursor: grabbing;
      }

      /* ============================================
         CLUSTER STYLES
         ============================================ */
      .cluster-ring {
        fill: rgba(59, 130, 246, 0.05);
        stroke-width: 2;
      }

      .cluster-label {
        font-size: 16px;
        font-weight: 600;
        text-anchor: middle;
        fill: #1f2937;
      }

      /* ============================================
         NODE STYLES
         ============================================ */
      .node-circle {
        stroke: rgba(255, 255, 255, 0.85);
        stroke-width: 1.4;
        cursor: pointer;
      }

      .node-label {
        font-size: 10px;
        text-anchor: middle;
        fill: #374151;
        pointer-events: none;
      }

      .node-label.hidden {
        display: none;
      }

      .confidence-indicator {
        font-size: 9px;
        text-anchor: middle;
        fill: #6b7280;
      }

      /* ============================================
         TOOLTIP & STATUS MESSAGES
         ============================================ */
      #tooltip {
        position: absolute;
        pointer-events: none;
        background: rgba(17, 24, 39, 0.92);
        color: #f9fafb;
        font-size: 12px;
        padding: 10px 12px;
        border-radius: 10px;
        line-height: 1.5;
        box-shadow: 0 10px 30px rgba(15, 23, 42, 0.25);
        min-width: 200px;
        max-width: 320px;
        display: none;
        z-index: 10;
      }

      #tooltip strong {
        font-weight: 600;
      }

      /* ============================================
         LEGEND
         ============================================ */
      #legend {
        display: flex;
        flex-wrap: wrap;
        gap: 12px;
        align-items: center;
        font-size: 13px;
      }

      .legend-item {
        display: inline-flex;
        align-items: center;
        gap: 6px;
        padding: 4px 8px;
        border-radius: 999px;
        background: rgba(148, 163, 184, 0.15);
      }

      .legend-swatch {
        width: 12px;
        height: 12px;
        border-radius: 50%;
        border: 1px solid rgba(15, 23, 42, 0.1);
      }

      /* ============================================
         FOOTER
         ============================================ */
      footer {
        font-size: 12px;
        color: #6b7280;
        display: flex;
        gap: 8px;
        flex-wrap: wrap;
      }

      footer code {
        background: rgba(148, 163, 184, 0.18);
        padding: 2px 6px;
        border-radius: 6px;
      }

      /* ============================================
         RESPONSIVE DESIGN
         ============================================ */
      @media (max-width: 768px) {
        header h1 {
          font-size: 18px;
        }

        .controls {
          width: 100%;
          justify-content: flex-start;
        }

        main {
          padding: 16px;
        }

        #viz-container {
          min-height: 550px;
        }
      }
    </style>
  </head>

  <body>
    <main>
      <!-- ============================================
           HEADER WITH TITLE AND CONTROLS
           ============================================ -->
      <header>
        <h1>Conversation Cluster Explorer</h1>
        <section class="controls">
          <!-- Toggle to show/hide node titles -->
          <label class="control">
            <input id="toggle-labels" type="checkbox" checked />
            <span>Show node titles</span>
          </label>

          <!-- Slider to control label text length -->
          <label class="control">
            <span>Label length</span>
            <input
              id="label-length"
              type="range"
              min="6"
              max="32"
              step="1"
              value="16"
            />
            <span id="label-length-value">16</span>
          </label>

          <!-- Slider to control spacing between nodes -->
          <label class="control">
            <span>Node padding</span>
            <input
              id="node-padding"
              type="range"
              min="5"
              max="40"
              step="1"
              value="20"
            />
            <span id="node-padding-value">20</span>
          </label>

          <!-- File input to load custom JSON data -->
          <label class="control">
            <span>Custom JSON</span>
            <input id="file-input" type="file" accept="application/json" />
          </label>
        </section>
      </header>

      <!-- ============================================
           LEGEND - Shows cluster colors and counts
           ============================================ -->
      <section id="legend"></section>

      <!-- ============================================
           VISUALIZATION CONTAINER
           ============================================ -->
      <div id="viz-container">
        <div id="svg-wrapper">
          <svg id="cluster-viz" xmlns="http://www.w3.org/2000/svg"></svg>
        </div>
        <div id="tooltip" role="tooltip"></div>
        <div id="status-message" hidden></div>
      </div>

      <!-- ============================================
           FOOTER WITH USAGE TIPS
           ============================================ -->
      <footer>
        <span>Tip: drag to pan, scroll to zoom.</span>
        <span>
          Update data by editing
          <code>results/visualization/clustered_nodes_full_k=3.json</code>
          then reloading.
        </span>
      </footer>
    </main>

    <!-- D3.js library for data visualization -->
    <script src="https://cdn.jsdelivr.net/npm/d3@7"></script>

    <script>
      /* ============================================
         CONFIGURATION CONSTANTS
         Adjust these values to customize the visualization
         ============================================ */
      const CONFIG = {
        // Path to your JSON data file
        DATA_PATH: "../test/output/s6_categories_assignments.json",

        // Font family for text rendering
        FONT_FAMILY:
          "'Noto Sans KR', 'Noto Sans SC', 'Noto Sans', 'Segoe UI', 'Helvetica Neue', Arial, sans-serif",

        // Canvas dimensions
        BASE_WIDTH: 1400,
        BASE_HEIGHT: 1100,

        // Spacing between cluster circles
        CLUSTER_SPACING: 160,

        // Minimum radius for cluster circles
        MIN_CLUSTER_RADIUS: 220,

        // Node size constraints
        MAX_NODE_RADIUS: 26,
        MIN_NODE_RADIUS: 10,

        // Color palette for clusters
        CLUSTER_COLORS: [
          "#4C6EF5", // Blue
          "#6FCF97", // Green
          "#F2994A", // Orange
          "#BB6BD9", // Purple
          "#56CCF2", // Cyan
          "#EB5757", // Red
          "#9B51E0", // Violet
          "#27AE60", // Dark Green
        ],
      };

      /* ============================================
         DOM ELEMENT REFERENCES
         ============================================ */
      const svg = d3
        .select("#cluster-viz")
        .attr("font-family", CONFIG.FONT_FAMILY)
        .attr("viewBox", [0, 0, CONFIG.BASE_WIDTH, CONFIG.BASE_HEIGHT])
        .attr("preserveAspectRatio", "xMidYMid meet");

      // Create zoom layer for pan and zoom functionality
      const zoomLayer = svg.append("g").attr("class", "zoom-layer");

      // Transparent background for capturing zoom events
      const background = zoomLayer
        .append("rect")
        .attr("class", "zoom-background")
        .attr("x", -CONFIG.BASE_WIDTH)
        .attr("y", -CONFIG.BASE_HEIGHT)
        .attr("width", CONFIG.BASE_WIDTH * 3)
        .attr("height", CONFIG.BASE_HEIGHT * 3)
        .attr("fill", "transparent");

      // Configure zoom behavior
      const zoom = d3
        .zoom()
        .scaleExtent([0.25, 4]) // Min and max zoom levels
        .on("zoom", (event) => {
          zoomLayer.attr("transform", event.transform);
        });

      svg.call(zoom).on("dblclick.zoom", null); // Disable double-click zoom

      // Get references to UI controls
      const tooltip = d3.select("#tooltip");
      const statusMessage = document.getElementById("status-message");
      const labelToggle = document.getElementById("toggle-labels");
      const labelLengthSlider = document.getElementById("label-length");
      const labelLengthValue = document.getElementById("label-length-value");
      const nodePaddingSlider = document.getElementById("node-padding");
      const nodePaddingValue = document.getElementById("node-padding-value");
      const fileInput = document.getElementById("file-input");

      // Initialize slider displays
      labelLengthValue.textContent = labelLengthSlider.value;
      nodePaddingValue.textContent = nodePaddingSlider.value;

      /* ============================================
         UTILITY FUNCTIONS
         ============================================ */

      /**
       * Format confidence value as percentage
       * @param {number} confidence - Confidence value between 0 and 1
       * @returns {string} Formatted percentage or "—" if undefined
       */
      function formatConfidence(confidence) {
        if (confidence === undefined || confidence === null) return "—";
        return (confidence * 100).toFixed(1) + "%";
      }

      /**
       * Wrap text labels to fit within a maximum character width
       * Handles both spaced text and continuous text (like CJK characters)
       * @param {d3.Selection} selection - D3 selection of text elements
       * @param {number} maxChars - Maximum characters per line
       */
      function wrapLabel(selection, maxChars = 16) {
        selection.each(function () {
          const text = d3.select(this);
          const raw =
            text.datum().title || `Conversation ${text.datum().node_id}`;

          if (!raw) {
            text.text("");
            return;
          }

          const sanitized = raw.trim();
          const hasSpaces = /\s/.test(sanitized);
          const segments = [];

          if (hasSpaces) {
            // For spaced text, wrap by words
            let line = "";
            sanitized.split(/\s+/).forEach((word) => {
              if ((line + " " + word).trim().length <= maxChars) {
                line = (line + " " + word).trim();
              } else {
                if (line) segments.push(line);
                line = word;
              }
            });
            if (line) segments.push(line);
          } else {
            // For continuous text, wrap by character count
            const chars = Array.from(sanitized);
            for (let i = 0; i < chars.length; i += maxChars) {
              segments.push(chars.slice(i, i + maxChars).join(""));
            }
          }

          // Create tspan elements for each line
          text.text(null);
          segments.forEach((segment, index) => {
            text
              .append("tspan")
              .attr("x", 0)
              .attr("dy", index === 0 ? "0em" : "1.1em")
              .text(segment);
          });
        });
      }

      /**
       * Show status message to user
       * @param {string} message - Message to display
       * @param {Object} options - Styling options
       */
      function showStatus(message, options = {}) {
        statusMessage.textContent = message;
        statusMessage.hidden = false;
        statusMessage.style.background =
          options.background || "rgba(17, 24, 39, 0.92)";
        statusMessage.style.color = options.color || "#f9fafb";
        statusMessage.style.padding = options.padding || "14px 18px";
        statusMessage.style.borderRadius = options.borderRadius || "16px";
        statusMessage.style.position = "absolute";
        statusMessage.style.top = "24px";
        statusMessage.style.left = "50%";
        statusMessage.style.transform = "translateX(-50%)";
        statusMessage.style.boxShadow = "0 18px 45px rgba(15, 23, 42, 0.28)";
        statusMessage.style.maxWidth = "520px";
        statusMessage.style.textAlign = "center";
        statusMessage.style.fontSize = "14px";
        statusMessage.style.lineHeight = "1.6";
      }

      /**
       * Hide status message
       */
      function hideStatus() {
        statusMessage.hidden = true;
      }

      /* ============================================
         LAYOUT CALCULATION FUNCTIONS
         ============================================ */

      /**
       * Build the cluster layout from raw data
       * @param {Array} clusters - Array of cluster definitions
       * @param {Array} nodes - Array of node data
       * @param {number} padding - Spacing between nodes
       * @returns {Array} Processed cluster data with positions
       */
      function buildClusterLayout(clusters, nodes, padding = 20) {
        // Group nodes by cluster ID
        const nodeGroups = d3.group(nodes, (d) => d.cluster_id);

        // Create color scale for clusters
        const colorScale = d3
          .scaleOrdinal()
          .domain(clusters.map((d) => d.id))
          .range(CONFIG.CLUSTER_COLORS);

        // Process each cluster
        const clusterData = clusters.map((cluster) => {
          const members = nodeGroups.get(cluster.id) || [];

          // Calculate cluster radius based on member count
          const baseRadius =
            CONFIG.MIN_CLUSTER_RADIUS + Math.sqrt(members.length || 1) * 18;

          // Scale diameter based on padding
          const paddingFactor = 1 + padding / 20;
          const diameter = baseRadius * 2 * paddingFactor;

          // Use D3's pack layout to position nodes in a circle
          const pack = d3.pack().size([diameter, diameter]).padding(padding);
          const root = d3
            .hierarchy({ children: members })
            .sum(() => 1)
            .sort(() => 0);

          // Calculate positions for each node
          const packed = pack(root)
            .leaves()
            .map((leaf) => ({
              ...leaf.data,
              x: leaf.x - diameter / 2,
              y: leaf.y - diameter / 2,
              r: Math.max(
                CONFIG.MIN_NODE_RADIUS,
                Math.min(CONFIG.MAX_NODE_RADIUS, leaf.r * 0.9)
              ),
              cluster_color: colorScale(cluster.id),
              cluster_name: cluster.name,
            }));

          return {
            id: cluster.id,
            name: cluster.name || cluster.id,
            description: cluster.description || "",
            size: members.length,
            radius: diameter / 2,
            nodes: packed,
            color: colorScale(cluster.id),
          };
        });

        // Position clusters horizontally
        const totalWidth =
          clusterData.reduce((sum, cluster) => sum + cluster.radius * 2, 0) +
          CONFIG.CLUSTER_SPACING * (clusterData.length + 1);

        let xCursor = CONFIG.CLUSTER_SPACING;
        clusterData.forEach((cluster) => {
          cluster.cx = xCursor + cluster.radius;
          cluster.cy = CONFIG.BASE_HEIGHT / 2;
          xCursor += cluster.radius * 2 + CONFIG.CLUSTER_SPACING;
        });

        // Update SVG viewBox to fit all clusters
        const viewWidth = Math.max(CONFIG.BASE_WIDTH, totalWidth);
        svg.attr("viewBox", [0, 0, viewWidth, CONFIG.BASE_HEIGHT]);
        background
          .attr("x", -viewWidth)
          .attr("width", viewWidth * 3)
          .attr("height", CONFIG.BASE_HEIGHT * 3);

        return clusterData;
      }

      /* ============================================
         RENDERING FUNCTIONS
         ============================================ */

      /**
       * Draw the legend showing cluster colors and sizes
       * @param {Array} clusterData - Processed cluster data
       */
      function drawLegend(clusterData) {
        const legend = d3.select("#legend");
        const items = legend
          .selectAll(".legend-item")
          .data(clusterData, (d) => d.id);

        const enter = items.enter().append("span").attr("class", "legend-item");

        enter
          .append("span")
          .attr("class", "legend-swatch")
          .style("background", (d) => d.color);

        enter.append("span").text((d) => `${d.name} (n=${d.size})`);

        items.exit().remove();
      }

      /**
       * Render the cluster visualization
       * @param {Array} clusterData - Processed cluster data
       */
      function render(clusterData) {
        // Clear existing visualization
        zoomLayer.selectAll(".cluster").remove();

        // Create cluster groups
        const clusterGroups = zoomLayer
          .selectAll(".cluster")
          .data(clusterData, (d) => d.id)
          .enter()
          .append("g")
          .attr("class", "cluster")
          .attr("transform", (d) => `translate(${d.cx}, ${d.cy})`);

        // Draw cluster circles
        clusterGroups
          .append("circle")
          .attr("class", "cluster-ring")
          .attr("r", (d) => d.radius)
          .attr("stroke", (d) => d3.color(d.color).darker(0.2));

        // Draw cluster labels
        clusterGroups
          .append("text")
          .attr("class", "cluster-label")
          .attr("y", (d) => -d.radius - 28)
          .text((d) => d.name);

        // Create node groups
        const nodeGroups = clusterGroups
          .append("g")
          .attr("class", "nodes")
          .selectAll(".node")
          .data((d) => d.nodes)
          .enter()
          .append("g")
          .attr("class", "node")
          .attr("transform", (d) => `translate(${d.x}, ${d.y})`);

        // Draw node circles
        nodeGroups
          .append("circle")
          .attr("class", "node-circle")
          .attr("r", (d) => d.r)
          .attr("fill", (d) => d.cluster_color)
          .attr("fill-opacity", 0.82)
          .on("mouseenter", (event, d) => {
            const [x, y] = d3.pointer(event, document.body);
            tooltip
              .style("display", "block")
              .style("left", `${x + 18}px`)
              .style("top", `${y + 18}px`)
              .html(
                `<strong>${d.title || `Conversation ${d.node_id}`}</strong><br/>
                 Cluster: ${d.cluster_name}<br/>
                 Confidence: ${formatConfidence(d.confidence)}`
              );
          })
          .on("mouseleave", () => tooltip.style("display", "none"));

        // Draw confidence indicators above nodes
        nodeGroups
          .append("text")
          .attr("class", "confidence-indicator")
          .attr("y", (d) => -d.r - 6)
          .text((d) =>
            d.confidence === undefined || d.confidence === null
              ? ""
              : (d.confidence * 100).toFixed(0) + "%"
          );

        // Draw node labels below nodes
        nodeGroups
          .append("text")
          .attr("class", "node-label")
          .classed("hidden", !labelToggle.checked)
          .attr("y", (d) => d.r + 10)
          .text((d) => d.title || `Conversation ${d.node_id}`)
          .each(function (d) {
            wrapLabel(d3.select(this), +labelLengthSlider.value);
          });
      }

      /**
       * Refresh label wrapping with new character limit
       * @param {number} maxChars - Maximum characters per line
       */
      function refreshLabels(maxChars) {
        svg.selectAll(".node-label").each(function (d) {
          const label = d3.select(this);
          label
            .text(d.title || `Conversation ${d.node_id}`)
            .selectAll("tspan")
            .remove();
          wrapLabel(label, maxChars);
        });
      }

      /* ============================================
         DATA LOADING AND INITIALIZATION
         ============================================ */

      /**
       * Convert s6_categories.json or s6_categories_assignments.json format to visualization format
       * @param {Object} categoryData - Data with categories, assignments, reason OR just assignments
       * @returns {Object} Data object with clusters and nodes
       */
      function convertCategoryDataToVisualization(categoryData) {
        // Check if this is already in the correct format
        if (categoryData.clusters && categoryData.nodes) {
          return categoryData;
        }

        // Check if this is s6_categories_assignments.json format (assignments only)
        const firstKey = Object.keys(categoryData)[0];
        const firstValue = categoryData[firstKey];
        if (
          firstValue &&
          typeof firstValue === "object" &&
          "category" in firstValue &&
          "confidence" in firstValue &&
          !categoryData.categories
        ) {
          // This is assignments-only format
          // Extract unique categories from assignments
          const categoriesSet = new Set();
          Object.values(categoryData).forEach((assignment) => {
            if (assignment.category) {
              categoriesSet.add(assignment.category);
            }
          });
          const categories = Array.from(categoriesSet);

          // Create clusters
          const clusters = categories.map((categoryName, idx) => ({
            id: idx,
            name: categoryName,
            description: "",
          }));

          // Create a map from category name to cluster ID
          const categoryToClusterId = {};
          categories.forEach((name, idx) => {
            categoryToClusterId[name] = idx;
          });

          // Convert assignments to nodes
          const nodes = Object.entries(categoryData).map(
            ([conversationId, assignment]) => ({
              node_id: conversationId,
              cluster_id: categoryToClusterId[assignment.category],
              confidence: assignment.confidence,
              title:
                assignment.conversation_title || `Conversation ${conversationId}`,
            })
          );

          return { clusters, nodes };
        }

        // Check if this is s6_categories.json format (full format)
        if (categoryData.categories && categoryData.assignments) {
          // Convert categories to clusters
          const clusters = categoryData.categories.map((categoryName, idx) => ({
            id: idx,
            name: categoryName,
            description: categoryData.reason || "",
          }));

          // Create a map from category name to cluster ID
          const categoryToClusterId = {};
          categoryData.categories.forEach((name, idx) => {
            categoryToClusterId[name] = idx;
          });

          // Convert assignments to nodes
          const nodes = Object.entries(categoryData.assignments).map(
            ([conversationId, assignment]) => {
              const assignObj =
                typeof assignment === "object" ? assignment : { category: assignment };
              return {
                node_id: conversationId,
                cluster_id: categoryToClusterId[assignObj.category],
                confidence: assignObj.confidence,
                title:
                  assignObj.conversation_title || `Conversation ${conversationId}`,
              };
            }
          );

          return { clusters, nodes };
        }

        return null;
      }

      /**
       * Load and render visualization from data object
       * @param {Object} data - Data object with clusters and nodes, or s6_categories format
       */
      function loadAndRender(data) {
        hideStatus();

        // Try to convert if it's in s6_categories.json format
        const converted = convertCategoryDataToVisualization(data);
        if (!converted) {
          showStatus(
            "Invalid data format. Expected either {clusters, nodes} or {categories, assignments, reason}."
          );
          return;
        }

        const clusters = converted.clusters || [];
        const nodes = converted.nodes || [];

        if (!clusters.length || !nodes.length) {
          showStatus(
            "No cluster or node data found in the selected JSON. Please confirm the file was generated by the visualization pipeline."
          );
          return;
        }

        // Store data globally for dynamic updates
        window.currentClusters = clusters;
        window.currentNodes = nodes;

        const padding = +nodePaddingSlider.value;
        const clusterData = buildClusterLayout(clusters, nodes, padding);
        drawLegend(clusterData);
        render(clusterData);

        // Set initial zoom and position
        svg.call(
          zoom.transform,
          d3.zoomIdentity
            .translate(CONFIG.BASE_WIDTH / 2, CONFIG.BASE_HEIGHT / 2)
            .scale(0.85)
        );
      }

      /**
       * Fetch and load the default JSON file
       */
      function fetchDefault() {
        d3.json(CONFIG.DATA_PATH)
          .then((data) => {
            if (!data) {
              throw new Error("No data returned");
            }
            loadAndRender(data);
          })
          .catch((error) => {
            console.warn("Failed to load default JSON:", error);
            const fileProtocol = window.location.protocol === "file:";
            const message = fileProtocol
              ? "Unable to load JSON via file:// due to browser security rules. Options:<br/><br/>• Serve this directory with a local web server (e.g. <code>python -m http.server</code>)<br/>• Or use the <strong>Custom JSON</strong> picker above to load the file manually."
              : "Could not fetch visualization JSON. Verify the path exists or use the Custom JSON picker to choose a file.";
            showStatus(message, {
              background: fileProtocol ? "rgba(59, 130, 246, 0.95)" : undefined,
            });
          });
      }

      /* ============================================
         EVENT LISTENERS
         ============================================ */

      // Initialize visualization on page load
      fetchDefault();

      // Toggle label visibility
      labelToggle.addEventListener("change", (event) => {
        svg.selectAll(".node-label").classed("hidden", !event.target.checked);
      });

      // Update label length
      labelLengthSlider.addEventListener("input", (event) => {
        const value = Number(event.target.value);
        labelLengthValue.textContent = String(value);
        refreshLabels(value);
      });

      // Update node padding
      nodePaddingSlider.addEventListener("input", (event) => {
        const value = Number(event.target.value);
        nodePaddingValue.textContent = String(value);

        // Re-render with new padding
        const currentData = {
          clusters: window.currentClusters || [],
          nodes: window.currentNodes || [],
        };

        if (currentData.clusters.length && currentData.nodes.length) {
          const clusterData = buildClusterLayout(
            currentData.clusters,
            currentData.nodes,
            value
          );
          drawLegend(clusterData);
          render(clusterData);
        }
      });

      // Adjust tooltip width on window resize
      window.addEventListener("resize", () => {
        const bbox = svg.node().getBoundingClientRect();
        tooltip.style("max-width", Math.max(220, bbox.width * 0.3) + "px");
      });

      // Load custom JSON file
      fileInput.addEventListener("change", (event) => {
        const file = event.target.files && event.target.files[0];
        if (!file) return;

        const reader = new FileReader();
        reader.onload = (loadEvent) => {
          try {
            const parsed = JSON.parse(loadEvent.target.result);
            loadAndRender(parsed);
          } catch (err) {
            showStatus(
              "Failed to parse JSON file. Please ensure you selected a valid visualization file."
            );
          }
        };
        reader.readAsText(file);
      });
    </script>
  </body>
</html>
