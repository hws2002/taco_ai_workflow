<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Interactive Cluster Bubble Visualization</title>

    <!-- Google Fonts for multi-language support -->
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Noto+Sans:wght@400;600&family=Noto+Sans+KR:wght@400;600&family=Noto+Sans+SC:wght@400;600&display=swap"
      rel="stylesheet"
    />

    <style>
      /* ============================================
         GLOBAL STYLES
         ============================================ */
      :root {
        color-scheme: light;
      }

      body {
        margin: 0;
        font-family: "Noto Sans KR", "Noto Sans SC", "Noto Sans", "Segoe UI",
          "Helvetica Neue", Arial, sans-serif;
        background: #f5f7fb;
        color: #1f2937;
      }

      main {
        display: flex;
        flex-direction: column;
        gap: 16px;
        padding: 18px 24px 32px 24px;
        min-height: 100vh;
        box-sizing: border-box;
      }

      /* ============================================
         HEADER & CONTROLS
         ============================================ */
      header {
        display: flex;
        flex-wrap: wrap;
        align-items: center;
        justify-content: space-between;
        gap: 12px;
      }

      header h1 {
        margin: 0;
        font-size: 22px;
        font-weight: 600;
      }

      .controls {
        display: flex;
        flex-wrap: wrap;
        gap: 16px;
        align-items: center;
      }

      .control {
        display: flex;
        align-items: center;
        gap: 8px;
        font-size: 14px;
        background: #ffffff;
        padding: 6px 12px;
        border-radius: 12px;
        box-shadow: 0 2px 10px rgba(15, 23, 42, 0.08);
      }

      /* ============================================
         VISUALIZATION CONTAINER
         ============================================ */
      #viz-container {
        flex: 1 1 auto;
        min-height: 1200px;
        background: #ffffff;
        border-radius: 18px;
        box-shadow: 0 12px 40px rgba(15, 23, 42, 0.12);
        position: relative;
        overflow: hidden;
        display: flex;
        flex-direction: column;
      }

      #svg-wrapper {
        flex: 1;
        width: 100%;
        height: 100%;
        position: relative;
      }

      svg {
        width: 100%;
        height: 100%;
        display: block;
        cursor: grab;
        position: absolute;
        top: 0;
        left: 0;
      }

      svg:active {
        cursor: grabbing;
      }

      /* ============================================
         CLUSTER STYLES
         ============================================ */
      .cluster-ring {
        fill: rgba(59, 130, 246, 0.05);
        stroke-width: 2;
      }

      .cluster-label {
        font-size: 16px;
        font-weight: 600;
        text-anchor: middle;
        fill: #1f2937;
      }

      /* ============================================
         NODE STYLES
         ============================================ */
      .node-circle {
        stroke: rgba(255, 255, 255, 0.85);
        stroke-width: 1.4;
        cursor: pointer;
      }

      .node-label {
        font-size: 10px;
        text-anchor: middle;
        fill: #374151;
        pointer-events: none;
      }

      .node-label.hidden {
        display: none;
      }

      .confidence-indicator {
        font-size: 9px;
        text-anchor: middle;
        fill: #6b7280;
      }

      /* ============================================
         EDGE STYLES
         ============================================ */
      .edge {
        fill: none;
        stroke: #94a3b8;
        pointer-events: none;
      }

      .edge.hidden {
        display: none;
      }

      .edge.intra-cluster {
        stroke: #64748b;
        stroke-dasharray: none;
      }

      .edge.inter-cluster {
        stroke: #94a3b8;
        stroke-dasharray: 4 2;
      }

      .edge.high-confidence {
        stroke: #3b82f6;
      }

      .edge.medium-confidence {
        stroke: #8b5cf6;
      }

      /* ============================================
         TOOLTIP & STATUS MESSAGES
         ============================================ */
      #tooltip {
        position: absolute;
        pointer-events: none;
        background: rgba(17, 24, 39, 0.92);
        color: #f9fafb;
        font-size: 12px;
        padding: 10px 12px;
        border-radius: 10px;
        line-height: 1.5;
        box-shadow: 0 10px 30px rgba(15, 23, 42, 0.25);
        min-width: 200px;
        max-width: 320px;
        display: none;
        z-index: 10;
      }

      #tooltip strong {
        font-weight: 600;
      }

      /* ============================================
         LEGEND
         ============================================ */
      #legend {
        display: flex;
        flex-wrap: wrap;
        gap: 12px;
        align-items: center;
        font-size: 13px;
      }

      .legend-item {
        display: inline-flex;
        align-items: center;
        gap: 6px;
        padding: 4px 8px;
        border-radius: 999px;
        background: rgba(148, 163, 184, 0.15);
      }

      .legend-swatch {
        width: 12px;
        height: 12px;
        border-radius: 50%;
        border: 1px solid rgba(15, 23, 42, 0.1);
      }

      /* ============================================
         FOOTER
         ============================================ */
      footer {
        font-size: 12px;
        color: #6b7280;
        display: flex;
        gap: 8px;
        flex-wrap: wrap;
      }

      footer code {
        background: rgba(148, 163, 184, 0.18);
        padding: 2px 6px;
        border-radius: 6px;
      }

      /* ============================================
         RESPONSIVE DESIGN
         ============================================ */
      @media (max-width: 768px) {
        header h1 {
          font-size: 18px;
        }

        .controls {
          width: 100%;
          justify-content: flex-start;
        }

        main {
          padding: 16px;
        }

        #viz-container {
          min-height: 550px;
        }
      }
    </style>
  </head>

  <body>
    <main>
      <!-- ============================================
           HEADER WITH TITLE AND CONTROLS
           ============================================ -->
      <header>
        <h1>Conversation Cluster Explorer</h1>
        <section class="controls">
          <!-- Toggle to show/hide node titles -->
          <label class="control">
            <input id="toggle-labels" type="checkbox" checked />
            <span>Show node titles</span>
          </label>

          <!-- Slider to control label text length -->
          <label class="control">
            <span>Label length</span>
            <input
              id="label-length"
              type="range"
              min="6"
              max="32"
              step="1"
              value="16"
            />
            <span id="label-length-value">16</span>
          </label>

          <!-- Slider to control spacing between nodes -->
          <label class="control">
            <span>Node padding</span>
            <input
              id="node-padding"
              type="range"
              min="5"
              max="40"
              step="1"
              value="20"
            />
            <span id="node-padding-value">20</span>
          </label>

          <!-- Toggle to show/hide edges -->
          <label class="control">
            <input id="toggle-edges" type="checkbox" checked />
            <span>Show edges</span>
          </label>

          <!-- Filter edges by type -->
          <label class="control">
            <span>Edge filter</span>
            <select id="edge-filter">
              <option value="all">All edges</option>
              <option value="hard">Hard edges only</option>
              <option value="insight">Insight edges only</option>
              <option value="intra">Intra-cluster only</option>
              <option value="inter">Inter-cluster only</option>
            </select>
          </label>

          <!-- File input to load custom JSON data -->
          <label class="control">
            <span>Custom JSON</span>
            <input id="file-input" type="file" accept="application/json" />
          </label>
        </section>
      </header>

      <!-- ============================================
           LEGEND - Shows cluster colors and counts
           ============================================ -->
      <section id="legend"></section>

      <!-- ============================================
           VISUALIZATION CONTAINER
           ============================================ -->
      <div id="viz-container">
        <div id="svg-wrapper">
          <svg id="cluster-viz" xmlns="http://www.w3.org/2000/svg"></svg>
        </div>
        <div id="tooltip" role="tooltip"></div>
        <div id="status-message" hidden></div>
      </div>

      <!-- ============================================
           FOOTER WITH USAGE TIPS
           ============================================ -->
      <footer>
        <span>Tip: drag to pan, scroll to zoom.</span>
        <span>
          Update data by editing
          <code>output/graph.json</code>
          then reloading, or use the Custom JSON picker above.
        </span>
      </footer>
    </main>

    <!-- D3.js library for data visualization -->
    <script src="https://cdn.jsdelivr.net/npm/d3@7"></script>

    <script>
      /* ============================================
         CONFIGURATION CONSTANTS
         Adjust these values to customize the visualization
         ============================================ */
      const CONFIG = {
        // Path to your JSON data file
        DATA_PATH: "../output/graph.json",

        // Font family for text rendering
        FONT_FAMILY:
          "'Noto Sans KR', 'Noto Sans SC', 'Noto Sans', 'Segoe UI', 'Helvetica Neue', Arial, sans-serif",

        // Canvas dimensions
        BASE_WIDTH: 1400,
        BASE_HEIGHT: 1100,

        // Spacing between cluster circles
        CLUSTER_SPACING: 160,

        // Minimum radius for cluster circles
        MIN_CLUSTER_RADIUS: 220,

        // Node size constraints
        MAX_NODE_RADIUS: 26,
        MIN_NODE_RADIUS: 10,

        // Color palette for clusters
        CLUSTER_COLORS: [
          "#4C6EF5", // Blue
          "#6FCF97", // Green
          "#F2994A", // Orange
          "#BB6BD9", // Purple
          "#56CCF2", // Cyan
          "#EB5757", // Red
          "#9B51E0", // Violet
          "#27AE60", // Dark Green
        ],

        // Edge visualization settings
        EDGE_OPACITY: {
          high: 0.6,
          medium: 0.4,
          default: 0.2,
        },
        EDGE_WIDTH: {
          high: 2.0,
          medium: 1.5,
          default: 1.0,
        },
      };

      /* ============================================
         DOM ELEMENT REFERENCES
         ============================================ */
      const svg = d3
        .select("#cluster-viz")
        .attr("font-family", CONFIG.FONT_FAMILY)
        .attr("viewBox", [0, 0, CONFIG.BASE_WIDTH, CONFIG.BASE_HEIGHT])
        .attr("preserveAspectRatio", "xMidYMid meet");

      // Create zoom layer for pan and zoom functionality
      const zoomLayer = svg.append("g").attr("class", "zoom-layer");

      // Transparent background for capturing zoom events
      const background = zoomLayer
        .append("rect")
        .attr("class", "zoom-background")
        .attr("x", -CONFIG.BASE_WIDTH)
        .attr("y", -CONFIG.BASE_HEIGHT)
        .attr("width", CONFIG.BASE_WIDTH * 3)
        .attr("height", CONFIG.BASE_HEIGHT * 3)
        .attr("fill", "transparent");

      // Configure zoom behavior
      const zoom = d3
        .zoom()
        .scaleExtent([0.25, 4]) // Min and max zoom levels
        .on("zoom", (event) => {
          zoomLayer.attr("transform", event.transform);
        });

      svg.call(zoom).on("dblclick.zoom", null); // Disable double-click zoom

      // Get references to UI controls
      const tooltip = d3.select("#tooltip");
      const statusMessage = document.getElementById("status-message");
      const labelToggle = document.getElementById("toggle-labels");
      const labelLengthSlider = document.getElementById("label-length");
      const labelLengthValue = document.getElementById("label-length-value");
      const nodePaddingSlider = document.getElementById("node-padding");
      const nodePaddingValue = document.getElementById("node-padding-value");
      const edgeToggle = document.getElementById("toggle-edges");
      const edgeFilter = document.getElementById("edge-filter");
      const fileInput = document.getElementById("file-input");

      // Initialize slider displays
      labelLengthValue.textContent = labelLengthSlider.value;
      nodePaddingValue.textContent = nodePaddingSlider.value;

      /* ============================================
         UTILITY FUNCTIONS
         ============================================ */

      /**
       * Format confidence value as percentage
       * @param {number} confidence - Confidence value between 0 and 1
       * @returns {string} Formatted percentage or "—" if undefined
       */
      function formatConfidence(confidence) {
        if (confidence === undefined || confidence === null) return "—";
        return (confidence * 100).toFixed(1) + "%";
      }

      /**
       * Get display title for a node
       * @param {Object} node - Node data
       * @returns {string} Display title
       */
      function getNodeTitle(node) {
        // Use title if available, otherwise use top keywords or orig_id
        if (node.title) return node.title;
        if (node.top_keywords && node.top_keywords.length > 0) {
          return node.top_keywords[0];
        }
        return node.orig_id || `Node ${node.id || node.node_id}`;
      }

      /**
       * Wrap text labels to fit within a maximum character width
       * Handles both spaced text and continuous text (like CJK characters)
       * @param {d3.Selection} selection - D3 selection of text elements
       * @param {number} maxChars - Maximum characters per line
       */
      function wrapLabel(selection, maxChars = 16) {
        selection.each(function () {
          const text = d3.select(this);
          const raw = getNodeTitle(text.datum());

          if (!raw) {
            text.text("");
            return;
          }

          const sanitized = raw.trim();
          const hasSpaces = /\s/.test(sanitized);
          const segments = [];

          if (hasSpaces) {
            // For spaced text, wrap by words
            let line = "";
            sanitized.split(/\s+/).forEach((word) => {
              if ((line + " " + word).trim().length <= maxChars) {
                line = (line + " " + word).trim();
              } else {
                if (line) segments.push(line);
                line = word;
              }
            });
            if (line) segments.push(line);
          } else {
            // For continuous text, wrap by character count
            const chars = Array.from(sanitized);
            for (let i = 0; i < chars.length; i += maxChars) {
              segments.push(chars.slice(i, i + maxChars).join(""));
            }
          }

          // Create tspan elements for each line
          text.text(null);
          segments.forEach((segment, index) => {
            text
              .append("tspan")
              .attr("x", 0)
              .attr("dy", index === 0 ? "0em" : "1.1em")
              .text(segment);
          });
        });
      }

      /**
       * Show status message to user
       * @param {string} message - Message to display
       * @param {Object} options - Styling options
       */
      function showStatus(message, options = {}) {
        statusMessage.textContent = message;
        statusMessage.hidden = false;
        statusMessage.style.background =
          options.background || "rgba(17, 24, 39, 0.92)";
        statusMessage.style.color = options.color || "#f9fafb";
        statusMessage.style.padding = options.padding || "14px 18px";
        statusMessage.style.borderRadius = options.borderRadius || "16px";
        statusMessage.style.position = "absolute";
        statusMessage.style.top = "24px";
        statusMessage.style.left = "50%";
        statusMessage.style.transform = "translateX(-50%)";
        statusMessage.style.boxShadow = "0 18px 45px rgba(15, 23, 42, 0.28)";
        statusMessage.style.maxWidth = "520px";
        statusMessage.style.textAlign = "center";
        statusMessage.style.fontSize = "14px";
        statusMessage.style.lineHeight = "1.6";
      }

      /**
       * Hide status message
       */
      function hideStatus() {
        statusMessage.hidden = true;
      }

      /* ============================================
         LAYOUT CALCULATION FUNCTIONS
         ============================================ */

      /**
       * Build the cluster layout from raw data
       * @param {Array} clusters - Array of cluster definitions
       * @param {Array} nodes - Array of node data
       * @param {number} padding - Spacing between nodes
       * @returns {Array} Processed cluster data with positions
       */
      function buildClusterLayout(clusters, nodes, padding = 20) {
        // Group nodes by cluster ID
        const nodeGroups = d3.group(nodes, (d) => d.cluster_id);

        // Create color scale for clusters
        const colorScale = d3
          .scaleOrdinal()
          .domain(clusters.map((d) => d.id))
          .range(CONFIG.CLUSTER_COLORS);

        // Process each cluster
        const clusterData = clusters.map((cluster) => {
          const members = nodeGroups.get(cluster.id) || [];

          // Calculate cluster radius based on member count
          const baseRadius =
            CONFIG.MIN_CLUSTER_RADIUS + Math.sqrt(members.length || 1) * 18;

          // Scale diameter based on padding
          const paddingFactor = 1 + padding / 20;
          const diameter = baseRadius * 2 * paddingFactor;

          // Use D3's pack layout to position nodes in a circle
          const pack = d3.pack().size([diameter, diameter]).padding(padding);
          const root = d3
            .hierarchy({ children: members })
            .sum(() => 1)
            .sort(() => 0);

          // Calculate positions for each node
          const packed = pack(root)
            .leaves()
            .map((leaf) => ({
              ...leaf.data,
              x: leaf.x - diameter / 2,
              y: leaf.y - diameter / 2,
              r: Math.max(
                CONFIG.MIN_NODE_RADIUS,
                Math.min(CONFIG.MAX_NODE_RADIUS, leaf.r * 0.9)
              ),
              cluster_color: colorScale(cluster.id),
              cluster_name: cluster.name,
              node_id: leaf.data.id, // Ensure node_id is set
            }));

          return {
            id: cluster.id,
            name: cluster.name || cluster.id,
            description: cluster.description || "",
            size: members.length,
            radius: diameter / 2,
            nodes: packed,
            color: colorScale(cluster.id),
          };
        });

        // Position clusters horizontally
        const totalWidth =
          clusterData.reduce((sum, cluster) => sum + cluster.radius * 2, 0) +
          CONFIG.CLUSTER_SPACING * (clusterData.length + 1);

        let xCursor = CONFIG.CLUSTER_SPACING;
        clusterData.forEach((cluster) => {
          cluster.cx = xCursor + cluster.radius;
          cluster.cy = CONFIG.BASE_HEIGHT / 2;
          xCursor += cluster.radius * 2 + CONFIG.CLUSTER_SPACING;
        });

        // Update SVG viewBox to fit all clusters
        const viewWidth = Math.max(CONFIG.BASE_WIDTH, totalWidth);
        svg.attr("viewBox", [0, 0, viewWidth, CONFIG.BASE_HEIGHT]);
        background
          .attr("x", -viewWidth)
          .attr("width", viewWidth * 3)
          .attr("height", CONFIG.BASE_HEIGHT * 3);

        return clusterData;
      }

      /* ============================================
         RENDERING FUNCTIONS
         ============================================ */

      /**
       * Build a lookup map from node ID to absolute position
       * @param {Array} clusterData - Processed cluster data
       * @returns {Map} Map of node_id to {x, y, cluster_id}
       */
      function buildNodePositionMap(clusterData) {
        const positionMap = new Map();

        clusterData.forEach(cluster => {
          cluster.nodes.forEach(node => {
            positionMap.set(node.id || node.node_id, {
              x: cluster.cx + node.x,
              y: cluster.cy + node.y,
              cluster_id: cluster.id,
            });
          });
        });

        return positionMap;
      }

      /**
       * Filter edges based on current filter selection
       * @param {Array} edges - All edges
       * @param {string} filterType - Filter type from edge-filter select
       * @returns {Array} Filtered edges
       */
      function filterEdges(edges, filterType) {
        if (filterType === "all") return edges;

        return edges.filter(edge => {
          switch (filterType) {
            case "hard":
              return edge.type === "hard";
            case "insight":
              return edge.type === "insight";
            case "intra":
              return edge.intraCluster === true;
            case "inter":
              return edge.intraCluster === false;
            default:
              return true;
          }
        });
      }

      /**
       * Render edges between nodes
       * @param {Array} edges - Edge data
       * @param {Map} positionMap - Node position lookup
       */
      function renderEdges(edges, positionMap) {
        // Remove existing edges
        zoomLayer.selectAll(".edge").remove();

        if (!edges || !edgeToggle.checked) return;

        // Filter edges based on current filter
        const filteredEdges = filterEdges(edges, edgeFilter.value);

        // Create edge group (render before nodes so edges are behind)
        const edgeGroup = zoomLayer.insert("g", ":first-child").attr("class", "edges");

        // Draw edges as lines
        edgeGroup
          .selectAll(".edge")
          .data(filteredEdges)
          .enter()
          .append("line")
          .attr("class", d => {
            const classes = ["edge"];
            if (d.intraCluster) classes.push("intra-cluster");
            else classes.push("inter-cluster");
            if (d.type === "hard") classes.push("high-confidence");
            else if (d.type === "insight") classes.push("medium-confidence");
            return classes.join(" ");
          })
          .attr("x1", d => {
            const sourcePos = positionMap.get(d.source);
            return sourcePos ? sourcePos.x : 0;
          })
          .attr("y1", d => {
            const sourcePos = positionMap.get(d.source);
            return sourcePos ? sourcePos.y : 0;
          })
          .attr("x2", d => {
            const targetPos = positionMap.get(d.target);
            return targetPos ? targetPos.x : 0;
          })
          .attr("y2", d => {
            const targetPos = positionMap.get(d.target);
            return targetPos ? targetPos.y : 0;
          })
          .attr("stroke-width", d => {
            return d.type === "hard" ? CONFIG.EDGE_WIDTH.high : CONFIG.EDGE_WIDTH.medium;
          })
          .attr("stroke-opacity", d => {
            return d.type === "hard" ? CONFIG.EDGE_OPACITY.high : CONFIG.EDGE_OPACITY.medium;
          });
      }

      /**
       * Draw the legend showing cluster colors and sizes
       * @param {Array} clusterData - Processed cluster data
       */
      function drawLegend(clusterData) {
        const legend = d3.select("#legend");
        const items = legend
          .selectAll(".legend-item")
          .data(clusterData, (d) => d.id);

        const enter = items.enter().append("span").attr("class", "legend-item");

        enter
          .append("span")
          .attr("class", "legend-swatch")
          .style("background", (d) => d.color);

        enter.append("span").text((d) => `${d.name} (n=${d.size})`);

        items.exit().remove();
      }

      /**
       * Render the cluster visualization
       * @param {Array} clusterData - Processed cluster data
       * @param {Array} edges - Edge data (optional)
       */
      function render(clusterData, edges = null) {
        // Clear existing visualization
        zoomLayer.selectAll(".cluster").remove();
        zoomLayer.selectAll(".edges").remove();

        // Build node position map for edge rendering
        const positionMap = buildNodePositionMap(clusterData);

        // Render edges first (so they appear behind nodes)
        if (edges && edges.length > 0) {
          renderEdges(edges, positionMap);
        }

        // Create cluster groups
        const clusterGroups = zoomLayer
          .selectAll(".cluster")
          .data(clusterData, (d) => d.id)
          .enter()
          .append("g")
          .attr("class", "cluster")
          .attr("transform", (d) => `translate(${d.cx}, ${d.cy})`);

        // Draw cluster circles
        clusterGroups
          .append("circle")
          .attr("class", "cluster-ring")
          .attr("r", (d) => d.radius)
          .attr("stroke", (d) => d3.color(d.color).darker(0.2));

        // Draw cluster labels
        clusterGroups
          .append("text")
          .attr("class", "cluster-label")
          .attr("y", (d) => -d.radius - 28)
          .text((d) => d.name);

        // Create node groups
        const nodeGroups = clusterGroups
          .append("g")
          .attr("class", "nodes")
          .selectAll(".node")
          .data((d) => d.nodes)
          .enter()
          .append("g")
          .attr("class", "node")
          .attr("transform", (d) => `translate(${d.x}, ${d.y})`);

        // Draw node circles
        nodeGroups
          .append("circle")
          .attr("class", "node-circle")
          .attr("r", (d) => d.r)
          .attr("fill", (d) => d.cluster_color)
          .attr("fill-opacity", 0.82)
          .on("mouseenter", (event, d) => {
            const [x, y] = d3.pointer(event, document.body);
            const title = getNodeTitle(d);
            const keywords = d.top_keywords ? d.top_keywords.slice(0, 3).join(", ") : "—";
            tooltip
              .style("display", "block")
              .style("left", `${x + 18}px`)
              .style("top", `${y + 18}px`)
              .html(
                `<strong>${title}</strong><br/>
                 ID: ${d.orig_id || d.id}<br/>
                 Cluster: ${d.cluster_name}<br/>
                 Confidence: ${formatConfidence(d.cluster_confidence || d.confidence)}<br/>
                 Keywords: ${keywords}`
              );
          })
          .on("mouseleave", () => tooltip.style("display", "none"));

        // Draw confidence indicators above nodes
        nodeGroups
          .append("text")
          .attr("class", "confidence-indicator")
          .attr("y", (d) => -d.r - 6)
          .text((d) => {
            const conf = d.cluster_confidence || d.confidence;
            return conf === undefined || conf === null
              ? ""
              : (conf * 100).toFixed(0) + "%";
          });

        // Draw node labels below nodes
        nodeGroups
          .append("text")
          .attr("class", "node-label")
          .classed("hidden", !labelToggle.checked)
          .attr("y", (d) => d.r + 10)
          .text((d) => getNodeTitle(d))
          .each(function (d) {
            wrapLabel(d3.select(this), +labelLengthSlider.value);
          });
      }

      /**
       * Refresh label wrapping with new character limit
       * @param {number} maxChars - Maximum characters per line
       */
      function refreshLabels(maxChars) {
        svg.selectAll(".node-label").each(function (d) {
          const label = d3.select(this);
          label
            .text(getNodeTitle(d))
            .selectAll("tspan")
            .remove();
          wrapLabel(label, maxChars);
        });
      }

      /* ============================================
         DATA LOADING AND INITIALIZATION
         ============================================ */

      /**
       * Parse graph.json format into clusters and nodes
       * @param {Object} data - Raw graph.json data
       * @returns {Object} {clusters, nodes, edges}
       */
      function parseGraphData(data) {
        // Check if this is the new graph.json format
        if (data.metadata && data.metadata.clusters) {
          // New format: graph.json from merge_graph.py
          const clusterMetadata = data.metadata.clusters;
          const clusters = Object.entries(clusterMetadata).map(([id, info]) => ({
            id: id,
            name: info.name,
            description: info.description,
            size: info.size,
            key_themes: info.key_themes
          }));

          return {
            clusters: clusters,
            nodes: data.nodes || [],
            edges: data.edges || []
          };
        } else {
          // Old format: clusters and nodes at top level
          return {
            clusters: data.clusters || [],
            nodes: data.nodes || [],
            edges: data.edges || []
          };
        }
      }

      /**
       * Load and render visualization from data object
       * @param {Object} data - Data object with clusters and nodes
       */
      function loadAndRender(data) {
        hideStatus();

        // Parse data based on format
        const parsed = parseGraphData(data);
        const clusters = parsed.clusters;
        const nodes = parsed.nodes;
        const edges = parsed.edges;

        if (!clusters.length || !nodes.length) {
          showStatus(
            "No cluster or node data found in the selected JSON. Please confirm the file was generated by the visualization pipeline."
          );
          return;
        }

        // Store data globally for dynamic updates
        window.currentClusters = clusters;
        window.currentNodes = nodes;
        window.currentEdges = edges;

        const padding = +nodePaddingSlider.value;
        const clusterData = buildClusterLayout(clusters, nodes, padding);
        drawLegend(clusterData);
        render(clusterData, edges);

        // Set initial zoom and position
        svg.call(
          zoom.transform,
          d3.zoomIdentity
            .translate(CONFIG.BASE_WIDTH / 2, CONFIG.BASE_HEIGHT / 2)
            .scale(0.85)
        );
      }

      /**
       * Fetch and load the default JSON file
       */
      function fetchDefault() {
        d3.json(CONFIG.DATA_PATH)
          .then((data) => {
            if (!data) {
              throw new Error("No data returned");
            }
            loadAndRender(data);
          })
          .catch((error) => {
            console.warn("Failed to load default JSON:", error);
            const fileProtocol = window.location.protocol === "file:";
            const message = fileProtocol
              ? "Unable to load JSON via file:// due to browser security rules. Options:<br/><br/>• Serve this directory with a local web server (e.g. <code>python -m http.server</code>)<br/>• Or use the <strong>Custom JSON</strong> picker above to load the file manually."
              : "Could not fetch visualization JSON. Verify the path exists or use the Custom JSON picker to choose a file.";
            showStatus(message, {
              background: fileProtocol ? "rgba(59, 130, 246, 0.95)" : undefined,
            });
          });
      }

      /* ============================================
         EVENT LISTENERS
         ============================================ */

      // Initialize visualization on page load
      fetchDefault();

      // Toggle label visibility
      labelToggle.addEventListener("change", (event) => {
        svg.selectAll(".node-label").classed("hidden", !event.target.checked);
      });

      // Update label length
      labelLengthSlider.addEventListener("input", (event) => {
        const value = Number(event.target.value);
        labelLengthValue.textContent = String(value);
        refreshLabels(value);
      });

      // Update node padding
      nodePaddingSlider.addEventListener("input", (event) => {
        const value = Number(event.target.value);
        nodePaddingValue.textContent = String(value);

        // Re-render with new padding
        const currentData = {
          clusters: window.currentClusters || [],
          nodes: window.currentNodes || [],
          edges: window.currentEdges || [],
        };

        if (currentData.clusters.length && currentData.nodes.length) {
          const clusterData = buildClusterLayout(
            currentData.clusters,
            currentData.nodes,
            value
          );
          drawLegend(clusterData);
          render(clusterData, currentData.edges);
        }
      });

      // Toggle edge visibility
      edgeToggle.addEventListener("change", (event) => {
        if (event.target.checked) {
          zoomLayer.selectAll(".edge").classed("hidden", false);
        } else {
          zoomLayer.selectAll(".edge").classed("hidden", true);
        }
      });

      // Filter edges
      edgeFilter.addEventListener("change", () => {
        const currentData = {
          clusters: window.currentClusters || [],
          nodes: window.currentNodes || [],
          edges: window.currentEdges || [],
        };

        if (currentData.clusters.length && currentData.nodes.length) {
          const padding = +nodePaddingSlider.value;
          const clusterData = buildClusterLayout(
            currentData.clusters,
            currentData.nodes,
            padding
          );
          render(clusterData, currentData.edges);
        }
      });

      // Adjust tooltip width on window resize
      window.addEventListener("resize", () => {
        const bbox = svg.node().getBoundingClientRect();
        tooltip.style("max-width", Math.max(220, bbox.width * 0.3) + "px");
      });

      // Load custom JSON file
      fileInput.addEventListener("change", (event) => {
        const file = event.target.files && event.target.files[0];
        if (!file) return;

        const reader = new FileReader();
        reader.onload = (loadEvent) => {
          try {
            const parsed = JSON.parse(loadEvent.target.result);
            loadAndRender(parsed);
          } catch (err) {
            showStatus(
              "Failed to parse JSON file. Please ensure you selected a valid visualization file."
            );
          }
        };
        reader.readAsText(file);
      });
    </script>
  </body>
</html>
